# abc149

## abc149-e

固有のパワーを持つ人間と両手で握手して幸福度を上げる。同じ組み合わせの握手はできない。

* 人数N ~100000 O(NlogN) まで
* 握手回数M ~N^2まで
* 幸福度 ~10^5

```
5 3
10 14 19 34 33
=> 202

9 14
1 3 5 110 24 21 34 5 3
=> 1837
```

真面目に解こうとすると、N^2の足し合わせをソートしてM回足すことになる。
O(N^2 * M)
⇒M回の繰り返しを避ける必要がある。


足し合わせ後の大きさに規則性はないか
```
一番大きい数 + 一番大きい数
二番大きい数 + 一番大きい数
一番大きい数 + 二番大きい数
↓移行の順序が曖昧
三番大きい数 + 一番大きい数
二番大きい数 + 二番大きい数
```
---

### 解法

* 定数X以上となる、握手の組み合わせ数を導出(O(N))
* 組み合わせ数がM以上の最小のXを二分探索で求める(O(NlogN))
* 定数Xからスコアを計算

### 抽象化

* ある条件(握手の回数はＭ回)下での、総和の最大値を求める問題
⇒結果となるパラメータから条件を求める小問題を作成
* 二分探索で提示された条件を満たすような結果パラメータを導出

### coding時の注意
* 中身が分かっている数列の二分探索はlower_bound(),upper_bound()を使うのが一番早い
    * 戻り値はlower_bound()-begin()でひくか、end()-lower_bound()から引くと良し
* 二分探索を書く時の初期値は注意。
    * leftの値は導出される解の最小値-1である必要がある。
    * rightの値は導出される解の最大値+1である必要がある。
### 所要時間
7時間


### 類題

Median of Median

## abc149-f
頂点を黒or白（共に1/2の確立）で塗り、全ての黒頂点を含む最小の部分木の中の白頂点の個数の期待値

input
* 頂点数N
* 辺 ~N-1  

output
* y/xに対して、xz === u (mod 1000000007)となるz


答えは木の形状で一意に定まる

### 検討
* ほぼ見当がつかず。
* 頂点数で一意に定まらないことは分かった。（形状によることがある）
* 最小の部分木であるため葉は黒となる。
 ⇒(部分木の頂点数 - 葉の数)/2で求める・・・？

### 解法1

* 各辺が部分木Sに含まれる確率の合計+1が部分木Sの頂点数の期待値となる。
    * 空グラフ(黒点が0)でない場合の話
* 辺の両端の頂点に黒点が含まれる確率を求めれば良い
    * この確率を求める段階でグラフの形状は加味されている
    * 導出式は、(2^e - 1)(2^(n-e)-1)/(2^n): eは辺より下位の頂点数
* 確率の合計+1 -(空グラフとなる確率1/(2^n))が部分木Sの頂点数の期待値
* 頂点数の期待値 - 黒丸の期待値(n/2)が答え
* 有理数b/aに対してaz=b(mod 1e9+7)となるzを求めるためには、aの逆元を求めれば良さそう。

### 解法2(頂点に注目)

* 穴あき頂点の個数の期待値を求める。
    * ⇒各頂点が穴あき状態となる確率の総和を求める。
* ある頂点が穴あき状態となるパターン数の計算
    * 自信が白であり、接続先の頂点に黒点を含むような辺がふたつ以上ある。
    * パターン数 = 2<sup>n-1</sup> - 1 - Σ(2<sup>e</sup> - 1)
        * 自信が白: 2<sup>n-1</sup>
        * 0の場合、1パターン
        * 1の場合、Σ(2<sup>e</sup> -1) パターン(辺の数だけ和算)
* 上記のパターン数を前頂点に渡って計算し、2<sup>n</sup>で割る

### 不明点
* (解法1)頂点数の期待値から黒丸の期待値(n/2)を引いているところ。
    * 頂点数/2を引くか、あるいは部分木Sの末端を除く頂点数/2を引くべきでは・・・？

### coding
* mod計算のオンパレード:累乗、逆元
    * 演算子オーバーロードが強すぎる
    * b/aに対して、az=b(mod 1e9+7)の導出は普通にb/aの逆元の計算でできた。
* 再起関数を使った深さ優先探索
    * 辺に対して子要素の数を記録する必要があるので、stackでは実装できず。。

### 抽象化
* 期待値計算問題
    * 分割して、個々の確率を求める問題にするのは典型らしい

# Tips

## 累積和

添字等で混乱しがち！
累積和を何も考えず書けるようにする
https://qiita.com/drken/items/56a6b68edef8fc605821

* s[i] : [0, i)区間の和
    * s[3] = a[0] + a[1] + a[2]
    * [2, 7)区間の和はs[7] - s[2]

## しゃくとり法
https://qiita.com/drken/items/ecd1a472d3a0e7db8dce

### ユースシーン
長さnの数列において、
* 「条件」を満たす区間のうち、最小・最大の長さを求める
* 「条件」を満たす区間を数え上げよ
　
### 方法
* 区間の開始地点を固定し、終了地点を条件を満たす範囲で動かす
* 区間の開始地点を1増やす。

## 二分探索系STLライブラリ

### lower_bound, upper_bound
共に、**昇順ソートされた**数列に対して適応する。
* lower_boundは探索したいkey以上のイテレータを返す。
* upper_boundは探索したいkeyより大きいイテレータを返す。
* 要素を取得するためにはアスタリスクを付ける
    * *Iter //Iter = 4(値)
* 要素番号を取得するためには.begin()で引く
    * Iter - a.begin() // 3(要素番号)
### binary_search
ソートされた配列やvectorの中に、keyがあるかどうかをTrue/Falseで返す。

## 部分的にWAになるとき

### オーバーフロー
int ⇒ llに変えよう
### 想定範囲外
* 配列のサイズ誤り
* 二分探索の開始点の誤り
    * left/rightは答えとなり得る範囲外の値からスタートする必要がある。

