# ddcon

## ddcon_b
期待値計算問題
* 数列（スライム）の並びに対して、選択されたスライムが右のスライムに合流する操作
    * スライムの数(N) - 1回行う

## 検討
* 一つ一つの期待値を導出する
    * 1体のスライムが歩く期待値
    * 右側のスライムとの選択順序によって歩く距離が変わる
    * **確率の計算を誤っていた**
下記の誤解
```
a b c dと並んでいたときのaの歩行距離
歩行距離がbまで=> 1/ 2
歩行距離がcまで=> 1/ 4 
  bより選択順が遅い条件下でcより早い遅いかは等確率と考えていた。
歩行距離がdまで=> 1/ 4
```

## 解答
* 正しい確率の計算
```
a b c d と並んでいたときのaの歩行距離
全パターンは{abc, acb, bac, bca, cab, cba}
歩行距離がbまで => 1 / 2 (abc, acb, cab)
歩行距離がcまで => 1 / 6 (bac)
歩行距離がdまで => 1 / 3 (bca, cba)

上記の確率にも規則性はあり、
終端以外 => 1/n - 1/(n+1)
終端 => 1/n 
となる。
```
* 確率の捉え方を変えると、
```
aがa-b間を通る => 1 
aがb-c間を通る => 1 / 2 (a,bのうちaの選択順が遅い)
aがc-d間を通る => 1 / 3 (a,b,cのうちcの選択順が遅い)
```
これで計算可能！

## 抽象化
* 確率の計算を行う時は、何が「同様に確からしいか」を確認する必要がある。
* mintの除算は積算の前でも辻褄を合わせてくれる

## 類題
Removing Blocks  
https://atcoder.jp/contests/agc028/tasks/agc028_b?lang=ja

# abc147

## abc147-e

### 検討
* ある地点x, yでの最小値を更新していけば、
    * ある地点x, yでの最小値がH,W地点での最小値とは限らない
    * 最小値を記録する二次元dpでは不可能
### 回答
* 三次元dp(T/F判定)

### coding
* 前の要素がtrueであるかを確認する際、範囲外の参照とならないように注意(一敗)

### 抽象化

* 単一の値を記憶するn次元dpではダメ
    * 複数の値のT/Fを記憶するn+1次元dpで実現する！
* 「任意の数列を足すか引くかして出る和の最小値」の算出でも使用可能

## abc147-f

### 検討
* num = iX + jDが成す数字において、
    * i = mのとき、j = 0+1+...+(m-1) ~ (N-1)+(N-2)+...+(N-m)
* ただ、i, jが別でもnumが一致してしまうパターンがある。
    * X => D, D=> Xに統合する？？
        * 場合分けが面倒だった。
        * 配列サイズが1になるとREとなる？？
* 区間の和集合の算出
    * カウンタを用意して、
        * leftでインクリメント/rightでデクリメント
        * カウンタが1以上のとき計算する
        
### 解答
* i = mごとの数列をmod D で管理する。
* f(m), f(m) + D , f(m)

### coding
* map型で同一キーをpushした場合、値がvector型ならば複数追加される
* 範囲for文使用時には、コンテナ内の要素を変更できないパターンがある
    * 変更したい場合は、auto &i と書く
    * https://cpprefjp.github.io/lang/cpp11/range_based_for.html



# abc148
## abc148-e
* n * n-2 * n-4 * ...の時の0の数

### 検討
* 何回10(5*2)を使うかがポイント
* nが奇数であれば0
* nが偶数であれば5の倍数の数(重複含む)
    * 10の倍数であれば+1
    * 50の倍数であればさらに+1
    * 250の倍数であればさらに+1

### coding
* 10^18はllの許容範囲

## abc148-f

* 木の上で青木君と高橋君が鬼ごっこを行う。
* 青木君⇒高橋君の順番で1マス動く
* 木の形状と2人の初期位置は与えられる。

### 検討（解答）

* 各頂点に対して青木君からの距離、高橋君からの距離を算出する。
* 高橋君の距離＞青木君の距離となる頂点の内高橋君の距離の最大値-1が答え

### coding
* queueを使った幅優先探索は意外と引っかかる
    * 通過した点を記憶しておかないとループする
    * q.front()で最初に入れたデータを参照する
        * q.back()ではない。
    * 親ノードに依存する処理はfor文中に行う。
        * 親ノードがpopされ次のwhile文になった時、選択したノードの親がどれか判別し難いため。


# abc149

## abc149-e

固有のパワーを持つ人間と両手で握手して幸福度を上げる。同じ組み合わせの握手はできない。

* 人数N ~100000 O(NlogN) まで
* 握手回数M ~N^2まで
* 幸福度 ~10^5

```
5 3
10 14 19 34 33
=> 202

9 14
1 3 5 110 24 21 34 5 3
=> 1837
```

真面目に解こうとすると、N^2の足し合わせをソートしてM回足すことになる。
O(N^2 * M)
⇒M回の繰り返しを避ける必要がある。


足し合わせ後の大きさに規則性はないか
```
一番大きい数 + 一番大きい数
二番大きい数 + 一番大きい数
一番大きい数 + 二番大きい数
↓移行の順序が曖昧
三番大きい数 + 一番大きい数
二番大きい数 + 二番大きい数
```
---

### 解法

* 定数X以上となる、握手の組み合わせ数を導出(O(N))
* 組み合わせ数がM以上の最小のXを二分探索で求める(O(NlogN))
* 定数Xからスコアを計算

### 抽象化

* ある条件(握手の回数はＭ回)下での、総和の最大値を求める問題
⇒結果となるパラメータから条件を求める小問題を作成
* 二分探索で提示された条件を満たすような結果パラメータを導出

### coding時の注意
* 中身が分かっている数列の二分探索はlower_bound(),upper_bound()を使うのが一番早い
    * 戻り値はlower_bound()-begin()でひくか、end()-lower_bound()から引くと良し
* 二分探索を書く時の初期値は注意。
    * leftの値は導出される解の最小値-1である必要がある。
    * rightの値は導出される解の最大値+1である必要がある。
### 所要時間
7時間


### 類題

Median of Median

## abc149-f
頂点を黒or白（共に1/2の確立）で塗り、全ての黒頂点を含む最小の部分木の中の白頂点の個数の期待値

input
* 頂点数N
* 辺 ~N-1  

output
* y/xに対して、xz === u (mod 1000000007)となるz


答えは木の形状で一意に定まる

### 検討
* ほぼ見当がつかず。
* 頂点数で一意に定まらないことは分かった。（形状によることがある）
* 最小の部分木であるため葉は黒となる。
 ⇒(部分木の頂点数 - 葉の数)/2で求める・・・？

### 解法1

* 各辺が部分木Sに含まれる確率の合計+1が部分木Sの頂点数の期待値となる。
    * 空グラフ(黒点が0)でない場合の話
* 辺の両端の頂点に黒点が含まれる確率を求めれば良い
    * この確率を求める段階でグラフの形状は加味されている
    * 導出式は、(2^e - 1)(2^(n-e)-1)/(2^n): eは辺より下位の頂点数
* 確率の合計+1 -(空グラフとなる確率1/(2^n))が部分木Sの頂点数の期待値
* 頂点数の期待値 - 黒丸の期待値(n/2)が答え
* 有理数b/aに対してaz=b(mod 1e9+7)となるzを求めるためには、aの逆元を求めれば良さそう。

### 解法2(頂点に注目)

* 穴あき頂点の個数の期待値を求める。
    * ⇒各頂点が穴あき状態となる確率の総和を求める。
* ある頂点が穴あき状態となるパターン数の計算
    * 自信が白であり、接続先の頂点に黒点を含むような辺がふたつ以上ある。
    * パターン数 = 2<sup>n-1</sup> - 1 - Σ(2<sup>e</sup> - 1)
        * 自信が白: 2<sup>n-1</sup>
        * 0の場合、1パターン
        * 1の場合、Σ(2<sup>e</sup> -1) パターン(辺の数だけ和算)
* 上記のパターン数を前頂点に渡って計算し、2<sup>n</sup>で割る

### 不明点
* (解法1)頂点数の期待値から黒丸の期待値(n/2)を引いているところ。
    * 頂点数/2を引くか、あるいは部分木Sの末端を除く頂点数/2を引くべきでは・・・？

### coding
* mod計算のオンパレード:累乗、逆元
    * 演算子オーバーロードが強すぎる
    * b/aに対して、az=b(mod 1e9+7)の導出は普通にb/aの逆元の計算でできた。
* 再起関数を使った深さ優先探索
    * 辺に対して子要素の数を記録する必要があるので、stackでは実装できず。。

### 抽象化
* 期待値計算問題
    * 分割して、個々の確率を求める問題にするのは典型らしい

# Tips

## 累積和

添字等で混乱しがち！
累積和を何も考えず書けるようにする
https://qiita.com/drken/items/56a6b68edef8fc605821

* s[i] : [0, i)区間の和
    * s[3] = a[0] + a[1] + a[2]
    * [2, 7)区間の和はs[7] - s[2]

## しゃくとり法
https://qiita.com/drken/items/ecd1a472d3a0e7db8dce

### ユースシーン
長さnの数列において、
* 「条件」を満たす区間のうち、最小・最大の長さを求める
* 「条件」を満たす区間を数え上げよ
　
### 方法
* 区間の開始地点を固定し、終了地点を条件を満たす範囲で動かす
* 区間の開始地点を1増やす。

## 二分探索系STLライブラリ

### lower_bound, upper_bound
共に、**昇順ソートされた**数列に対して適応する。
* lower_boundは探索したいkey以上のイテレータを返す。
* upper_boundは探索したいkeyより大きいイテレータを返す。
* 要素を取得するためにはアスタリスクを付ける
    * *Iter //Iter = 4(値)
* 要素番号を取得するためには.begin()で引く
    * Iter - a.begin() // 3(要素番号)
### binary_search
ソートされた配列やvectorの中に、keyがあるかどうかをTrue/Falseで返す。

## 部分的にWAになるとき

### オーバーフロー
int ⇒ llに変えよう
### 想定範囲外
* 配列のサイズ誤り
* 二分探索の開始点の誤り
    * left/rightは答えとなり得る範囲外の値からスタートする必要がある。


## sort時のルールを定義したいとき

第一要素のみを降順、第二要素はtrueが最初に来るように
```
bool cmp(const pair<ll, bool> &a, const pair<ll, bool> &b){
    if (a.first != b.first){
        return a.first < b.first;
    } else {
        return a.second > b.second;
    }
}

sort(range[i].begin(), range[i].end(), cmp);
```

## mapの使い方

### 宣言/代入
```
map<ll, vector<P>> mp;
mp.insert(make_pair(i, p));
mp.emplace(i, p);
```
### 

## 順列生成ライブラリ

next_permutation(v.begin(), v.end())

## priority_queueの使い方

```
#include <bits/stdc++.h>
using namespace std;
#define MOD 1000000007
#define rep(i, n) for(int i = 0; i < (int)(n); i++)
typedef long long ll;

typedef struct{
    int mem1;
    int mem2;
} test;

int main(){

    auto compare = [](const test& a, const test& b){ 
        if (a.mem1 != b.mem1){
            return a.mem1 > b.mem1;
        } else {
            return a.mem2 > b.mem2;
        }
    };
    priority_queue<test, vector<test>, decltype(compare)> p(compare);

    p.push({1,2});
    p.push({7,2});
    p.push({3,2});
    p.push({4,2});
    p.push({6,2});
    p.push({3,2});
    p.push({1,5});

    while(!p.empty()){
        printf("%d %d\n", p.top().mem1, p.top().mem2);
        p.pop();
    }

    /*
    1 2
    1 5
    3 2
    3 2
    4 2
    6 2
    7 2
    */

}
```

